<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>urlnote.app</title>
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: white;
            color: #333;
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .header {
            color: #111;
            padding: 20px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: space-between;

        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .content {
            padding: 20px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            background: white;
            color: #333;
            border: 1px solid #ccc;
            padding: 6px 12px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #f5f5f5;
        }

        .btn.active {
            background: #111;
            color: white;
        }

        .password-group {
            display: none;
            align-items: center;
            gap: 8px;
        }

        .password-group.show {
            display: flex;
        }

        .password-input {
            padding: 6px 8px;
            border: 1px solid #ccc;
            font-size: 14px;
            width: 150px;
        }

        .password-input:focus {
            outline: none;
            border-color: #333;
        }

        .encryption-status {
            font-size: 12px;
            color: #666;
        }

        .editor-container {
            position: relative;
        }

        .note-area {
            width: 100%;
            min-height: 400px;
            border: 1px solid transparent;
            padding: 15px;
            font-size: 16px;
            line-height: 1.6;
            background: white;
            outline: none;
            overflow-y: auto;
        }

        .note-area:focus-within {
            border-color: #ccc;
        }

        /* Tiptap Editor Styling */
        .ProseMirror {
            outline: none;
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            min-height: 400px;
        }

        .ProseMirror p.is-editor-empty:first-child::before {
            content: attr(data-placeholder);
            float: left;
            color: #999;
            pointer-events: none;
            height: 0;
        }

        .ProseMirror h1 {
            font-size: 1.8em;
            font-weight: 600;
            margin: 1em 0 0.5em 0;
            padding-bottom: 0.3em;
        }

        .ProseMirror h2 {
            font-size: 1.5em;
            font-weight: 600;
            margin: 1em 0 0.5em 0;
        }

        .ProseMirror h3 {
            font-size: 1.3em;
            font-weight: 600;
            margin: 1em 0 0.5em 0;
        }

        .ProseMirror h4,
        .ProseMirror h5,
        .ProseMirror h6 {
            font-weight: 600;
            margin: 1em 0 0.5em 0;
        }

        .ProseMirror p {
            margin: 0.5em 0;
        }

        .ProseMirror ul,
        .ProseMirror ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .ProseMirror li p {
            margin: 0.2em 0;
        }

        .ProseMirror blockquote {
            border-left: 3px solid #ddd;
            padding-left: 1em;
            margin: 1em 0;
            color: #666;
            font-style: italic;
        }

        .ProseMirror code {
            background: #f0f0f0;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9em;
        }

        .ProseMirror pre {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 3px;
            padding: 10px;
            overflow-x: auto;
            margin: 1em 0;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .ProseMirror pre code {
            background: none;
            padding: 0;
        }

        .ProseMirror a {
            color: #0066cc;
            text-decoration: underline;
        }

        .ProseMirror strong {
            font-weight: 600;
        }

        .ProseMirror em {
            font-style: italic;
        }

        .ProseMirror hr {
            border: none;
            border-top: 1px solid #ddd;
            margin: 2em 0;
        }

        .url-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .url-label {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
        }

        .url-display {
            background: #f8f8f8;
            border: 1px solid #ddd;
            padding: 10px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            word-break: break-all;
            margin-bottom: 10px;
        }

        .copy-btn {
            background: #111;
            color: white;
            border: none;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
        }

        .copy-btn:hover {
            background: #333;
        }

        .status {
            margin-top: 10px;
            padding: 8px;
            font-size: 13px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .status.success {
            background: #f0f8f0;
            color: #0a5a0a;
            border: 1px solid #ccc;
            opacity: 1;
        }

        .status.error {
            background: #f8f0f0;
            color: #5a0a0a;
            border: 1px solid #ccc;
            opacity: 1;
        }

        .tip {
            margin-top: 20px;
            padding: 15px;
            background: #f8f8f8;
            border-left: 3px solid #111;
            font-size: 13px;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            border: 1px solid #111;
            padding: 20px;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }

        .modal-content h3 {
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .modal-content p {
            margin-bottom: 15px;
            font-size: 14px;
            color: #666;
        }

        .modal-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            font-size: 14px;
            margin-bottom: 15px;
        }

        .modal-input:focus {
            outline: none;
            border-color: #333;
        }

        .modal-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .modal-btn {
            padding: 8px 16px;
            border: 1px solid #ccc;
            font-size: 14px;
            cursor: pointer;
            background: white;
        }

        .modal-btn.primary {
            background: #111;
            color: white;
            border-color: #111;
        }

        .modal-btn:hover {
            background: #f5f5f5;
        }

        .modal-btn.primary:hover {
            background: #333;
        }

        @media (max-width: 600px) {
            .controls {
                flex-direction: column;
                align-items: flex-start;
            }

            .password-group {
                width: 100%;
            }

            .password-input {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>urlnote.app</h1>
            <p>easily share notes with a url</p>
        </div>

        <div class="content">
            <div class="editor-container">
                <div id="noteText" class="note-area"></div>
            </div>

            <div class="controls">
                <button id="passwordToggle" class="btn">Password</button>
                <div id="passwordGroup" class="password-group">
                    <input
                        type="password"
                        id="passwordInput"
                        class="password-input"
                        placeholder="Password..."
                    />
                    <span class="encryption-status" id="encryptionStatus">Not encrypted</span>
                </div>
            </div>

            <div class="url-section">
                <label class="url-label">Shareable URL:</label>
                <div id="urlDisplay" class="url-display">
                    Start typing to generate your shareable URL...
                </div>
                <button id="copyBtn" class="copy-btn">Copy URL</button>
                <div id="status" class="status"></div>
            </div>

            <div class="tip">
                <strong>Shortcuts:</strong> **bold**, *italic*, # headers, > quotes, `code`, - lists • <strong>Privacy:</strong> Notes stored in URL only
            </div>
        </div>
    </div>

    <!-- Password Modal -->
    <div id="passwordModal" class="modal">
        <div class="modal-content">
            <h3>Password Required</h3>
            <p>This note is password protected. Enter the password to view it:</p>
            <input type="password" id="modalPasswordInput" class="modal-input" placeholder="Enter password...">
            <div class="modal-buttons">
                <button id="modalUnlockBtn" class="modal-btn primary">Unlock</button>
                <button id="modalCancelBtn" class="modal-btn">Cancel</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { Editor } from 'https://esm.sh/@tiptap/core@2.1.13'
        import StarterKit from 'https://esm.sh/@tiptap/starter-kit@2.1.13'
        import Placeholder from 'https://esm.sh/@tiptap/extension-placeholder@2.1.13'

        // Get elements
        const urlDisplay = document.getElementById('urlDisplay');
        const copyBtn = document.getElementById('copyBtn');
        const status = document.getElementById('status');
        const passwordToggle = document.getElementById('passwordToggle');
        const passwordGroup = document.getElementById('passwordGroup');
        const passwordInput = document.getElementById('passwordInput');
        const encryptionStatus = document.getElementById('encryptionStatus');
        const passwordModal = document.getElementById('passwordModal');
        const modalPasswordInput = document.getElementById('modalPasswordInput');
        const modalUnlockBtn = document.getElementById('modalUnlockBtn');
        const modalCancelBtn = document.getElementById('modalCancelBtn');

        let isPasswordEnabled = false;
        let currentEncryptedData = null;
        let editor = null;

        // Enhanced compression with encryption prefix
        const ENCRYPTED_PREFIX = 'ENC:';

        // Debounce function for performance
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Initialize Tiptap Editor
        function initEditor() {
            editor = new Editor({
                element: document.getElementById('noteText'),
                extensions: [
                    StarterKit,
                    Placeholder.configure({
                        placeholder: `Type your note (markdown supported)`
                    })
                ],
                content: '',
                onUpdate: ({ editor }) => {
                    debouncedUpdateUrl();
                },
                editorProps: {
                    attributes: {
                        class: 'prose prose-sm max-w-none',
                    },
                },
            });
        }

        // Helper function to convert HTML to Markdown-ish text
        function htmlToMarkdown(html) {
            const temp = document.createElement('div');
            temp.innerHTML = html;

            let text = '';

            function processNode(node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    text += node.textContent;
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    switch (node.tagName.toLowerCase()) {
                        case 'h1':
                            text += '# ' + node.textContent + '\n\n';
                            break;
                        case 'h2':
                            text += '## ' + node.textContent + '\n\n';
                            break;
                        case 'h3':
                            text += '### ' + node.textContent + '\n\n';
                            break;
                        case 'h4':
                            text += '#### ' + node.textContent + '\n\n';
                            break;
                        case 'h5':
                            text += '##### ' + node.textContent + '\n\n';
                            break;
                        case 'h6':
                            text += '###### ' + node.textContent + '\n\n';
                            break;
                        case 'p':
                            if (node.textContent.trim() === '') {
                                // Empty paragraph - preserve as empty line
                                text += '\n';
                            } else {
                                // Process children first to handle inline formatting
                                Array.from(node.childNodes).forEach(processNode);
                                text += '\n\n';
                            }
                            break;
                        case 'strong':
                        case 'b':
                            text += '**' + node.textContent + '**';
                            break;
                        case 'em':
                        case 'i':
                            text += '*' + node.textContent + '*';
                            break;
                        case 'code':
                            if (node.parentNode.tagName.toLowerCase() !== 'pre') {
                                text += '`' + node.textContent + '`';
                            } else {
                                text += node.textContent;
                            }
                            break;
                        case 'pre':
                            text += '```\n' + node.textContent + '\n```\n\n';
                            break;
                        case 'blockquote':
                            text += '> ' + node.textContent.replace(/\n/g, '\n> ') + '\n\n';
                            break;
                        case 'ul':
                            Array.from(node.children).forEach(li => {
                                text += '- ' + li.textContent + '\n';
                            });
                            text += '\n';
                            break;
                        case 'ol':
                            Array.from(node.children).forEach((li, index) => {
                                text += (index + 1) + '. ' + li.textContent + '\n';
                            });
                            text += '\n';
                            break;
                        case 'br':
                            text += '  \n'; // Two spaces + newline for markdown line break
                            break;
                        case 'hr':
                            text += '---\n\n';
                            break;
                        case 'a':
                            text += '[' + node.textContent + '](' + node.href + ')';
                            break;
                        default:
                            // For other elements, process children
                            Array.from(node.childNodes).forEach(processNode);
                    }
                }
            }

            Array.from(temp.childNodes).forEach(processNode);

            // Clean up extra newlines but preserve intentional line breaks
            return text.replace(/\n\n\n+/g, '\n\n').trim();
        }

        // Helper function to convert markdown text back to HTML
        function markdownToHtml(markdown) {
            let html = '';
            const lines = markdown.split('\n');
            let i = 0;

            while (i < lines.length) {
                const line = lines[i];

                if (line.startsWith('# ')) {
                    const level = line.match(/^#+/)[0].length;
                    html += `<h${level}>${line.slice(level + 1)}</h${level}>`;
                    i++;
                } else if (line.startsWith('> ')) {
                    html += `<blockquote>${line.slice(2)}</blockquote>`;
                    i++;
                } else if (line.startsWith('- ')) {
                    html += '<ul>';
                    while (i < lines.length && lines[i].startsWith('- ')) {
                        html += `<li>${lines[i].slice(2)}</li>`;
                        i++;
                    }
                    html += '</ul>';
                } else if (line.match(/^\d+\. /)) {
                    html += '<ol>';
                    while (i < lines.length && lines[i].match(/^\d+\. /)) {
                        html += `<li>${lines[i].replace(/^\d+\. /, '')}</li>`;
                        i++;
                    }
                    html += '</ol>';
                } else if (line.startsWith('```')) {
                    html += '<pre><code>';
                    i++;
                    while (i < lines.length && !lines[i].startsWith('```')) {
                        html += lines[i] + '\n';
                        i++;
                    }
                    html += '</code></pre>';
                    i++; // Skip closing ```
                } else if (line.trim() === '') {
                    // Preserve empty lines as empty paragraphs for spacing
                    html += '<p></p>';
                    i++;
                } else {
                    // Regular paragraph - process inline formatting and line breaks
                    let paragraphContent = line;

                    // Handle markdown line breaks (two spaces at end of line)
                    if (paragraphContent.endsWith('  ')) {
                        paragraphContent = paragraphContent.slice(0, -2) + '<br>';
                    }

                    // Handle inline formatting
                    paragraphContent = paragraphContent
                        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                        .replace(/\*(.*?)\*/g, '<em>$1</em>')
                        .replace(/`([^`]+)`/g, '<code>$1</code>')
                        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');

                    html += `<p>${paragraphContent}</p>`;
                    i++;
                }
            }

            return html || '<p></p>';
        }

        // Crypto functions
        async function deriveKey(password, salt) {
            const encoder = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                { name: 'PBKDF2' },
                false,
                ['deriveKey']
            );

            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
        }

        async function encryptNote(note, password) {
            if (!password) return note;

            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(note);
                const salt = crypto.getRandomValues(new Uint8Array(16));
                const iv = crypto.getRandomValues(new Uint8Array(12));

                const key = await deriveKey(password, salt);
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    data
                );

                const combined = new Uint8Array(salt.length + iv.length + encrypted.byteLength);
                combined.set(salt, 0);
                combined.set(iv, salt.length);
                combined.set(new Uint8Array(encrypted), salt.length + iv.length);

                const base64 = btoa(String.fromCharCode(...combined));
                return ENCRYPTED_PREFIX + base64;
            } catch (error) {
                console.error('Encryption error:', error);
                throw new Error('Failed to encrypt note');
            }
        }

        async function decryptNote(encryptedNote, password) {
            if (!encryptedNote.startsWith(ENCRYPTED_PREFIX)) {
                return encryptedNote;
            }

            try {
                const base64Data = encryptedNote.substring(ENCRYPTED_PREFIX.length);
                const combined = new Uint8Array(atob(base64Data).split('').map(c => c.charCodeAt(0)));

                const salt = combined.slice(0, 16);
                const iv = combined.slice(16, 28);
                const encrypted = combined.slice(28);

                const key = await deriveKey(password, salt);
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encrypted
                );

                const decoder = new TextDecoder();
                return decoder.decode(decrypted);
            } catch (error) {
                console.error('Decryption error:', error);
                throw new Error('Failed to decrypt note - incorrect password?');
            }
        }

        function isEncrypted(data) {
            return data && data.startsWith(ENCRYPTED_PREFIX);
        }

        async function encodeNote(note) {
            try {
                let processedNote = note;

                if (isPasswordEnabled && passwordInput.value) {
                    processedNote = await encryptNote(note, passwordInput.value);
                }

                return LZString.compressToEncodedURIComponent(processedNote);
            } catch (error) {
                showStatus('Encryption failed: ' + error.message, 'error');
                return LZString.compressToEncodedURIComponent(note);
            }
        }

        async function decodeNote(encodedNote, password = null) {
            try {
                const decompressed = LZString.decompressFromEncodedURIComponent(encodedNote);

                if (isEncrypted(decompressed)) {
                    if (!password) {
                        currentEncryptedData = decompressed;
                        return null;
                    }
                    return await decryptNote(decompressed, password);
                }

                return decompressed;
            } catch (error) {
                console.error('Error decoding note:', error);
                throw error;
            }
        }

        function updateEncryptionStatus() {
            if (isPasswordEnabled && passwordInput.value) {
                encryptionStatus.textContent = 'Encrypted';
            } else {
                encryptionStatus.textContent = 'Not encrypted';
            }
        }

        async function loadNoteFromUrl() {
            const hash = window.location.hash.substring(1);
            if (hash) {
                try {
                    const decodedNote = await decodeNote(hash);
                    if (decodedNote === null) {
                        showPasswordModal();
                        return;
                    }

                    // Set content in editor using improved markdown conversion
                    if (editor) {
                        const html = markdownToHtml(decodedNote);
                        editor.commands.setContent(html);
                    }

                    updateUrlDisplay();
                } catch (e) {
                    console.error('Error decoding note from URL:', e);
                    showStatus('Error loading note from URL', 'error');
                }
            }
        }

        async function updateUrl() {
            if (!editor) return;

            // Get markdown-like content from editor
            const htmlContent = editor.getHTML();
            const markdownContent = htmlToMarkdown(htmlContent);

            if (markdownContent.trim()) {
                const encodedNote = await encodeNote(markdownContent);
                window.history.replaceState(null, null, `#${encodedNote}`);
            } else {
                window.history.replaceState(null, null, window.location.pathname);
            }
            updateUrlDisplay();
        }

        function updateUrlDisplay() {
            const currentUrl = window.location.href;
            urlDisplay.textContent = currentUrl;
        }

        async function copyToClipboard() {
            try {
                await navigator.clipboard.writeText(window.location.href);
                showStatus('URL copied to clipboard', 'success');
            } catch (err) {
                const textArea = document.createElement('textarea');
                textArea.value = window.location.href;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showStatus('URL copied to clipboard', 'success');
            }
        }

        function showStatus(message, type) {
            status.textContent = message;
            status.className = `status ${type}`;
            setTimeout(() => {
                status.style.opacity = '0';
                setTimeout(() => {
                    status.className = 'status';
                }, 300);
            }, 3000);
        }

        function showPasswordModal() {
            passwordModal.classList.add('show');
            modalPasswordInput.focus();
        }

        function hidePasswordModal() {
            passwordModal.classList.remove('show');
            modalPasswordInput.value = '';
        }

        async function unlockWithPassword() {
            const password = modalPasswordInput.value;
            if (!password) {
                showStatus('Please enter a password', 'error');
                return;
            }

            try {
                const decryptedNote = await decryptNote(currentEncryptedData, password);

                if (editor) {
                    const html = markdownToHtml(decryptedNote);
                    editor.commands.setContent(html);
                }

                updateUrlDisplay();
                hidePasswordModal();
                showStatus('Note unlocked successfully', 'success');
            } catch (error) {
                showStatus('Incorrect password', 'error');
                modalPasswordInput.value = '';
                modalPasswordInput.focus();
            }
        }

        // Debounced functions
        const debouncedUpdateUrl = debounce(updateUrl, 300);

        // Event listeners
        copyBtn.addEventListener('click', copyToClipboard);

        passwordToggle.addEventListener('click', () => {
            isPasswordEnabled = !isPasswordEnabled;
            passwordToggle.classList.toggle('active', isPasswordEnabled);
            passwordGroup.classList.toggle('show', isPasswordEnabled);

            if (isPasswordEnabled) {
                passwordInput.focus();
            } else {
                passwordInput.value = '';
            }

            updateEncryptionStatus();
            debouncedUpdateUrl();
        });

        passwordInput.addEventListener('input', () => {
            updateEncryptionStatus();
            debouncedUpdateUrl();
        });

        modalUnlockBtn.addEventListener('click', unlockWithPassword);
        modalCancelBtn.addEventListener('click', hidePasswordModal);

        modalPasswordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                unlockWithPassword();
            }
        });

        passwordModal.addEventListener('click', (e) => {
            if (e.target === passwordModal) {
                hidePasswordModal();
            }
        });

        // Initialize everything
        initEditor();
        setTimeout(() => {
            loadNoteFromUrl();
            updateUrlDisplay();
            updateEncryptionStatus();
        }, 100);
    </script>
</body>
</html>
